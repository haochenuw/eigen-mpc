#include <obliv.oh>
#include "linear.h"
#include "linear.oh"
#include "fixed.h"
#include "fixed.oh"
#include "util.h"



// reduce a  symmetric, positive semidefinite matrix to tridiagonal form
void tridiag(void *v) {
	double time_start = wallClock(); 
	size_t d = ls->a.d[0]; 
	ofixed_t *a = malloc((d*d)*sizeof(ofixed_t));
	for (size_t ii = 0; ii < d*d; ii++){
		ofxied_init(&a[ii]);
	}
	// read data into the system.
	ofixed_t *u = malloc(d*sizeof(ofixed_t));
	ofixed_t *uscaled = malloc(d*sizeof(ofixed_t)); 
	ofixed_t *p = malloc(d*sizeof(ofixed_t));
	for (size_t ii =0; ii < d; ii++)
	{
		ofixed_init(&u[ii]);
		ofixed_init(&uscaled[ii]);
		ofixed_init(&p[ii]);
	}

	ofixed_t temp;
        ofixed_init(&temp);
	ofixed_t temp_norm;
	ofixed_init(&temp_norm); 
	ofixed_t tempH;
        ofixed_init(&tempH);
	ofixed_t tempK;
        ofixed_init(&tempK);
        ofixed_t temp0;
        ofixed_init(&temp0);
        obig  temp5;
        ~obliv() obig_init(&temp5, ls->precision);
	
        if(read_symmetric_linear_system(ls, a, b)) {
                fprintf(stderr, "Could not read inputs.");
                ls->beta.len = -1;
                free(a);
                free(b);
                return;
        }

	
        // allocate output vector if not already done and we are party 2
        if(!(ls->beta.value) && ocCurrentParty() == 2) {
                ls->beta.len = d*d;
                ls->beta.value = malloc(d*d * sizeof(uint64_t));
        }

        if(ocCurrentParty() == 2) {printf("OT time: %f\n", wallClock() - time_start);}

	// The Householder reduction 
	for (size_t i=0; i < d-2; i++)
	{
		// compute the norm of the i-th sub-column. 
		for(size_t j = i+1; j < d; j++){
			ofixed_mul(&temp, a[idx(j,i)], a[idx(j,i)], ls->precision);
			ofixed_add(&temp_norm, temp, temp_norm); 
		}
		ofixed_sqrt(&temp_norm, temp_norm, ls->precision);

		// construct the vector u.
		for(size_t jj = i+1; jj <d ;jj++){
			ofixed_add(&u[jj], u[jj], a[idx(jj,i)]); 
		}
		ofixed_add(&u[ii+1], u[ii+1], temp_norm); 

		// compute H = 1/2*norm(u)^2. 
		// a simpler formula is H = norm(x)(norm(x) + x1). 		
		ofixed_add(&tempH, temp_norm, a[idx(i+1,i)]); 
		ofixed_mul(&tempH, temp_norm, tempH, ls->precision); 

		//  compute uscaled = u/H. 
		for (size_t k = 0; k < d; k++){
			ofixed_div(&uscaled[k], u[k], tempH, ls->precision); 
		}
		// Matrix multiplication. Computing  p = A*uscaled.
		for (size_t i =0; i < d; i++){
			for(size_t j =0; j < d; j++){
				ofixed_mul(&temp, a[idx(i,j)], uscaled[j], ls->precision); 
				ofixed_add(&p[i], p[i], temp); 
			}
		}

		// Compute K.  This part is entirely a dot product. 
		for (size_t ii = 0; ii < d; ii++){
			ofixed_mul(&temp, p[ii], uscaled[ii], ls->precision); 
			ofxied_add(&tempK, temp, tempK); 
		}	
		// divide by a constant 2. 
		obig_shr_native_signed(&temp5, tempK, 1);
       		obig_copy(&tempK, temp5);
			

		// We will use the memory of p to change it to q in-place.
		for (size_t ii = 0; ii <d ; ii++){
			ofixed_mul(&temp, tempK, u[ii], ls->precision);
			ofixed_sub(&p[ii], p[ii], temp); 
		}
		// Now p -> q, and we have A = A - qu^T - uq^T. 
		for(size_t i = 0; i < dd; i++){
			for(size_t j = 0; j < dd; j++){
				ofixed_mul(&temp, q[i], u[j], ls->precision);
				ofixed_sub(&a[idx(i,j)], temp, a[idx(i,j)]);
				ofixed_mul(&temp, u[i], q[j], ls->precision); 
				ofixed_sub(&a[idx(i,j)], temp, a[idx(i,j)]); 
			}
		}
		
	}
	for (size_t i =0; i < d; i ++){
		for (size_t j= 0; j < d, j++){
			ofixed_reveal(ls->beta+d*i+j, a[idx(i,j)],2)); 
		}
	}
	// free all variables
	ofixed_free(&temp);
	obig_free(&temp5); 

        for (size_t ii = 0; ii < d*d; ii++) {
                ofixed_free(&a[ii]);
        }
        for (size_t ii = 0; ii < d; ii++) {
                ofixed_free(&u[ii]);
                ofixed_free(&uscaled[ii]);
		ofixed_free(&p[ii]);
        }
        free(a);
        free(uscaled);
        free(u);
	free(p);
        return;
 
}
